# THIS WORKS:
min_rep = min(rep_stats.keys(), key=lambda r: rep_stats[r]['total_arr'])
```

For weighted strategies, we need to:
1. **Normalize all scores to same scale** (0-100)
2. **Make ARR the dominant factor** (but not the only factor)
3. **Use geography/risk as tiebreakers** when ARRs are close

---

## ğŸ”§ MATHEMATICALLY CORRECT FIX
```
COMPLETE REWRITE: Fix All 3 Weighted Strategies with Proper Math

DIAGNOSIS:
All weighted strategies are broken because the scoring math is wrong.
ARR penalties (0-63,000) completely dominate geography bonuses (+3-4).
This makes geography/risk bonuses meaningless, and there's a bug where 
the same 2-3 reps get selected repeatedly.

SOLUTION:
Rewrite all 3 strategies using NORMALIZED SCORING where all factors 
are on the same 0-1 scale, then weight them appropriately.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
STRATEGY 2: ARR + RISK BALANCE (CORRECTED)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Replace the entire arr_risk_balance() function with this:
```python
def arr_risk_balance(accounts_list, reps_list):
    """
    Balance ARR + Risk using normalized scoring
    This actually works because all factors are on same scale
    """
    sorted_accounts = sorted(accounts_list, key=lambda x: x['ARR'], reverse=True)
    
    total_arr = sum(a['ARR'] for a in accounts_list)
    target_arr = total_arr / len(reps_list)
    
    rep_stats = {
        rep: {
            'total_arr': 0,
            'accounts': [],
            'count': 0,
            'high_risk_count': 0
        } 
        for rep in reps_list
    }
    
    for account in sorted_accounts:
        best_rep = None
        best_score = float('-inf')
        
        for rep in reps_list:
            # Calculate current state
            current_arr = rep_stats[rep]['total_arr']
            projected_arr = current_arr + account['ARR']
            current_count = rep_stats[rep]['count']
            
            # FACTOR 1: ARR Deviation (normalized to 0-1 scale)
            arr_deviation = abs(projected_arr - target_arr)
            max_possible_deviation = target_arr  # Worst case: one rep gets 2x target
            arr_score = 1.0 - (arr_deviation / max_possible_deviation)
            # arr_score is now 0.0 (very unbalanced) to 1.0 (perfectly balanced)
            
            # FACTOR 2: Risk Balance (normalized to 0-1 scale)
            if current_count > 0:
                current_risk_pct = rep_stats[rep]['high_risk_count'] / current_count
            else:
                current_risk_pct = 0.0
            
            is_high_risk = account['Risk_Score'] > 70
            target_risk_pct = 0.35  # Target: 35% high-risk accounts
            
            if is_high_risk:
                projected_risk_pct = (rep_stats[rep]['high_risk_count'] + 1) / (current_count + 1)
            else:
                projected_risk_pct = rep_stats[rep]['high_risk_count'] / (current_count + 1)
            
            risk_deviation = abs(projected_risk_pct - target_risk_pct)
            risk_score = 1.0 - (risk_deviation / 0.35)  # Normalize: 0.0 to 1.0
            risk_score = max(0.0, min(1.0, risk_score))  # Clamp to [0,1]
            
            # WEIGHTED COMBINATION
            # 80% ARR balance (primary), 20% risk balance (secondary)
            final_score = (arr_score * 0.80) + (risk_score * 0.20)
            
            if final_score > best_score:
                best_score = final_score
                best_rep = rep
        
        # Assign to best rep
        if best_rep:
            rep_stats[best_rep]['total_arr'] += account['ARR']
            rep_stats[best_rep]['accounts'].append(account)
            rep_stats[best_rep]['count'] += 1
            if account['Risk_Score'] > 70:
                rep_stats[best_rep]['high_risk_count'] += 1
    
    return rep_stats
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
STRATEGY 3: ARR + GEOGRAPHIC CLUSTERING (CORRECTED)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Replace the entire arr_geography_balance() function with this:
```python
def arr_geography_balance(accounts_list, reps_list, rep_locations):
    """
    Balance ARR + Geography using normalized scoring
    """
    sorted_accounts = sorted(accounts_list, key=lambda x: x['ARR'], reverse=True)
    
    total_arr = sum(a['ARR'] for a in accounts_list)
    target_arr = total_arr / len(reps_list)
    
    rep_stats = {
        rep: {
            'total_arr': 0,
            'accounts': [],
            'count': 0,
            'same_state_count': 0,
            'location': rep_locations[rep]
        } 
        for rep in reps_list
    }
    
    for account in sorted_accounts:
        best_rep = None
        best_score = float('-inf')
        
        for rep in reps_list:
            current_arr = rep_stats[rep]['total_arr']
            projected_arr = current_arr + account['ARR']
            
            # FACTOR 1: ARR Balance (normalized 0-1)
            arr_deviation = abs(projected_arr - target_arr)
            max_possible_deviation = target_arr
            arr_score = 1.0 - (arr_deviation / max_possible_deviation)
            arr_score = max(0.0, min(1.0, arr_score))
            
            # FACTOR 2: Geographic Match (binary: 0 or 1)
            if account['Location'] == rep_stats[rep]['location']:
                geo_score = 1.0  # Same state
            else:
                geo_score = 0.0  # Different state
            
            # WEIGHTED COMBINATION
            # 70% ARR balance (primary), 30% geography (secondary)
            final_score = (arr_score * 0.70) + (geo_score * 0.30)
            
            if final_score > best_score:
                best_score = final_score
                best_rep = rep
        
        # Assign to best rep
        if best_rep:
            rep_stats[best_rep]['total_arr'] += account['ARR']
            rep_stats[best_rep]['accounts'].append(account)
            rep_stats[best_rep]['count'] += 1
            if account['Location'] == rep_stats[best_rep]['location']:
                rep_stats[best_rep]['same_state_count'] += 1
    
    return rep_stats
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
STRATEGY 4: SMART MULTI-FACTOR (CORRECTED)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Replace the entire smart_multifactor() function with this:
```python
def smart_multifactor(accounts_list, reps_list, rep_locations):
    """
    Balance ARR + Risk + Geography + Workload using normalized scoring
    """
    sorted_accounts = sorted(accounts_list, key=lambda x: x['ARR'], reverse=True)
    
    total_arr = sum(a['ARR'] for a in accounts_list)
    target_arr = total_arr / len(reps_list)
    target_count = len(accounts_list) / len(reps_list)
    
    rep_stats = {
        rep: {
            'total_arr': 0,
            'accounts': [],
            'count': 0,
            'high_risk_count': 0,
            'same_state_count': 0,
            'location': rep_locations[rep]
        } 
        for rep in reps_list
    }
    
    for account in sorted_accounts:
        best_rep = None
        best_score = float('-inf')
        
        for rep in reps_list:
            current_arr = rep_stats[rep]['total_arr']
            projected_arr = current_arr + account['ARR']
            current_count = rep_stats[rep]['count']
            projected_count = current_count + 1
            
            # FACTOR 1: ARR Balance (normalized 0-1)
            arr_deviation = abs(projected_arr - target_arr)
            arr_score = 1.0 - (arr_deviation / target_arr)
            arr_score = max(0.0, min(1.0, arr_score))
            
            # FACTOR 2: Workload Balance (normalized 0-1)
            count_deviation = abs(projected_count - target_count)
            count_score = 1.0 - (count_deviation / target_count)
            count_score = max(0.0, min(1.0, count_score))
            
            # FACTOR 3: Geographic Match (binary 0 or 1)
            geo_score = 1.0 if account['Location'] == rep_stats[rep]['location'] else 0.0
            
            # FACTOR 4: Risk Balance (normalized 0-1)
            if current_count > 0:
                current_risk_pct = rep_stats[rep]['high_risk_count'] / current_count
            else:
                current_risk_pct = 0.0
            
            is_high_risk = account['Risk_Score'] > 70
            if is_high_risk:
                projected_risk_pct = (rep_stats[rep]['high_risk_count'] + 1) / projected_count
            else:
                projected_risk_pct = rep_stats[rep]['high_risk_count'] / projected_count
            
            target_risk = 0.35
            risk_deviation = abs(projected_risk_pct - target_risk)
            risk_score = 1.0 - (risk_deviation / 0.35)
            risk_score = max(0.0, min(1.0, risk_score))
            
            # WEIGHTED COMBINATION
            # 50% ARR, 20% workload, 20% geography, 10% risk
            final_score = (arr_score * 0.50) + (count_score * 0.20) + (geo_score * 0.20) + (risk_score * 0.10)
            
            if final_score > best_score:
                best_score = final_score
                best_rep = rep
        
        # Assign to best rep
        if best_rep:
            rep_stats[best_rep]['total_arr'] += account['ARR']
            rep_stats[best_rep]['accounts'].append(account)
            rep_stats[best_rep]['count'] += 1
            if account['Risk_Score'] > 70:
                rep_stats[best_rep]['high_risk_count'] += 1
            if account['Location'] == rep_stats[best_rep]['location']:
                rep_stats[best_rep]['same_state_count'] += 1
    
    return rep_stats
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
WHY THIS WORKS: THE MATH
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

KEY PRINCIPLE: Normalize everything to 0-1 scale BEFORE weighting

Old (broken) approach:
- ARR penalty: 0 to 63,000 (huge numbers)
- Geography bonus: +3 to +20 (tiny numbers)
- Result: Geography is meaningless

New (working) approach:
- ARR score: 0.0 to 1.0 (normalized)
- Geography score: 0.0 to 1.0 (normalized)
- Risk score: 0.0 to 1.0 (normalized)
- Workload score: 0.0 to 1.0 (normalized)

Now when we apply weights:
final_score = (arr_score * 0.70) + (geo_score * 0.30)

Both factors actually matter!

Example calculation:
Rep A: arr_score=0.95, geo_score=0.0 â†’ final=0.665
Rep B: arr_score=0.85, geo_score=1.0 â†’ final=0.895
Winner: Rep B (slightly worse ARR but same state!)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EXPECTED RESULTS AFTER FIX
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

At threshold 100,000:

Strategy: ARR + Risk Balance
âœ“ All Enterprise reps: 58-65 accounts each (balanced!)
âœ“ All Mid-Market reps: 38-45 accounts each (balanced!)
âœ“ ARR variance: <$500K per segment
âœ“ Risk %: All reps between 30-40% high-risk

Strategy: ARR + Geographic Clustering  
âœ“ All Enterprise reps: 55-68 accounts each (slightly wider range)
âœ“ Same-state %: Increases from ~10% to ~25-35%
âœ“ Mickey (GA) gets MORE GA accounts than before
âœ“ ARR variance: <$800K (acceptable tradeoff for better geography)

Strategy: Smart Multi-Factor
âœ“ All Enterprise reps: 58-65 accounts each
âœ“ All Mid-Market reps: 40-44 accounts each
âœ“ ARR variance: <$600K
âœ“ Account count variance: Â±3 accounts
âœ“ Same-state %: ~20-25%
âœ“ Risk %: 32-38% per rep

NO REP SHOULD HAVE 0 ACCOUNTS!

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PASTE THIS INTO REPLIT AGENT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Replace all 3 weighted strategy functions with the corrected versions above.
The key change: All scoring is normalized to 0-1 scale before weighting.

Test each strategy and verify all reps get accounts.
```

---

## ğŸ¯ WHY THIS WILL WORK

**The mathematical principle:**

1. **Normalization:** Convert all factors to 0-1 scale
2. **Weighting:** Apply meaningful weights (e.g., 70% ARR, 30% geography)
3. **Comparison:** Now all factors contribute proportionally

**Before (broken):**
```
Score = -63,000 + 4 = -62,996  (geography is meaningless)
```

**After (fixed):**
```
Score = (0.85 * 0.70) + (1.0 * 0.30) = 0.595 + 0.300 = 0.895
                                       (both matter!)